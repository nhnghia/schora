options{  JDK_VERSION = "1.6";  static = false;}PARSER_BEGIN(ChorReader)package fr.lri.schora.chorD.parser;import fr.lri.schora.chorD.*;import fr.lri.schora.expr.*;public class ChorReader{  Condition getCondition(Token t) throws ParseException  {	String str = "";	  for (int i=1; i<t.beginLine; i++)	  	str += "\n";	  for (int i=1; i<t.beginColumn; i++)	  	str += " ";	  str += t.image;	  return _ParserTool.parser(str);	}}PARSER_END(ChorReader)TOKEN_MGR_DECLS : {	static int commentNesting = 0;}< * > SKIP : /* Ignoring spaces/tabs/newlines*/{	  " "	| "\r"	| "\t"	| "\n"	| <"//" (~["\n"])* "\n">}MORE:{	< "/*" > {commentNesting++;} : IN_COMMENT}<IN_COMMENT> MORE:{  	<~[]>}<IN_COMMENT> SKIP :{	  < "/*" > {commentNesting++;} 	| < "*/" > {commentNesting--;	    if(commentNesting == 0) {	        SwitchTo(DEFAULT);	    }	}}< DEFAULT > TOKEN : /*OPERATOR*/{    < SKIPP : "skip" > : IN_EVENT  	| < LPARAM  : "[" > : IN_CONDITION	| < LPAREN  : "(" >	| < EVENT   : (["A"-"Z"] | ["a"-"z"] | "_") > : IN_EVENT}      < IN_CONDITION > TOKEN :{    < RPARAM    : "]" > : IN_GUARD  | < CONDITION : (~["]"])+ >}< IN_GUARD > TOKEN:{  	< LOOP      : "*" > : DEFAULT	| < IF      : "|>" >: DEFAULT}< IN_EVENT > TOKEN :{    < ASSIGN    : ":=" > : IN_EVENT     | < PARALLEL: "|" > : DEFAULT	| < CHOICE  : "+" > : DEFAULT	| < SEQUENCE: ";" > : DEFAULT	| < INTERRUP: "[>" >: DEFAULT	| < RPAREN  : ")" > : IN_EVENT	| < EVENTS  : ~[] > : IN_EVENT}< * > TOKEN :{	< UNEXPECTED_CHAR : ~[] >}ChorD start():{  ChorD c1, c2;}{  c1 = expression_1()  (    < PARALLEL >    c2 = expression_1()    {      Parallel p = new Parallel();      p.spec = c1;      p.rightSpec = c2;      c1 = p;    }  |  	< CHOICE >  	c2 = expression_1()  	{  	  Choice c = new Choice();  	  c.spec = c1;      c.rightSpec = c2;      c1 = c;  	}  )*  {    return c1;  }}ChorD expression_1():{  ChorD c1, c2;}{  c1 = expression_2()  (  	< SEQUENCE >	c2 = expression_2()    {      Sequence  c = new Sequence();      c.spec = c1;      c.rightSpec = c2;      c1 = c;    }  )*  {    return c1;  }}ChorD expression_2():{  ChorD spec;  Token t;}{  < LPARAM >  t = < CONDITION >  < RPARAM >  (  	 < LOOP >  	{		spec = expression_3();	    Loop  c = new Loop();      	c.guard = getCondition(t);      	c.spec = spec;      	return c;    }  |  	< IF >  	{		spec = expression_3();	    If  cc = new If();      	cc.guard = getCondition(t);      	cc.spec = spec;      	return cc;  	} )|  spec = expression_3()  {	return spec;  }}ChorD expression_3():{  ChorD c1, c2;}{  c1 = expression_4()  (  	< INTERRUP >	c2 = expression_4()    {      Interruption  c = new Interruption();      c.spec = c1;      c.rightSpec = c2;      c1 = c;    }  )*  {    return c1;  }}ChorD expression_4():{  ChorD c;}{  c = expression_5()  {    return c;  }|   < LPAREN >  c = start()  < RPAREN >  {    fr.lri.schora.chorD.Bracket cc = new fr.lri.schora.chorD.Bracket();    cc.spec = c;    return cc;  }}ChorD expression_5():{  Token t;  String str = "";}{ 	< SKIPP >   {     return new Skip();   } | 	t = < EVENT > 	{	  for (int i=1; i<t.beginLine; i++)	  	str += "\n";	  for (int i=1; i<t.beginColumn; i++)	  	str += " ";	  str += t.image; 	} 	( 	  t = < EVENTS > 	  { 	    	str += t.image; 	  } 	)* 	{	  return _ParserTool.parserEvent(str); 	}}